"use strict";(self.webpackChunkwebsite_miralis=self.webpackChunkwebsite_miralis||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"end-2024-progress-report","metadata":{"permalink":"/blog/end-2024-progress-report","source":"@site/blog/2024-11-31-end-2024.md","title":"Fall 2024 progress report","description":"The year concludes with the addition of 300 commits to Miralis and successful deployment of Debian running securely on ACE with a policy that isolates the linux kernel from the OpenSBI firmware (see image below). We can run the classical commands There have been some changes in the composition of the Miralis team, Fr\xe9d\xe9ric and I are replacing Sofia and No\xe9. Additionally, we have open-sourced a second tool, Virt-Sail, a transpiler currently under development that converts Sail code into Rust.","date":"2024-12-01T00:00:00.000Z","tags":[{"inline":false,"label":"News","permalink":"/blog/tags/news","description":"News and updates about Miralis"}],"readingTime":5.725,"hasTruncateMarker":true,"authors":[{"name":"Fran\xe7ois Costa","description":"Low latency engineer at Mathrix.","page":{"permalink":"/blog/authors/francois-141"},"socials":{"github":"https://github.com/francois141","website":"https://francois141.github.io"},"imageURL":"https://github.com/francois141/francois141/blob/main/pictures/portrait1.jpg?raw=true","key":"francois141"}],"frontMatter":{"slug":"end-2024-progress-report","title":"Fall 2024 progress report","authors":["francois141"],"tags":["news"]},"unlisted":false,"lastUpdatedAt":1738150900000,"nextItem":{"title":"Summer 2024 progress report","permalink":"/blog/summer-2024-progress-report"}},"content":"The year concludes with the addition of 300 commits to **Miralis** and successful deployment of **Debian** running securely on **ACE** with a policy that isolates the linux kernel from the OpenSBI firmware (see image below). We can run the classical commands There have been some changes in the composition of the Miralis team, Fr\xe9d\xe9ric and I are replacing Sofia and No\xe9. Additionally, we have open-sourced a second tool, [**Virt-Sail**](https://github.com/CharlyCst/virt-sail), a transpiler currently under development that converts **Sail** code into **Rust**.\\n\\n\x3c!--truncate--\x3e\\n\\n![ACE demo with protect payload policy](../static/blog/board_demo.jpeg)\\n\\n\\n## 3 new security policies\\n\\nBuilding on the strong momentum established by Sofia and No\xe9, Charly, Fr\xe9d\xe9ric, and I have developed three security policies. Additionally, Miralis can now boot various Linux distributions, including Ubuntu, Fedora, OpenSUSE, and Debian. Charly focused on virtualizing interrupts, Fr\xe9d\xe9ric took responsibility for integrating the **Keystone** security monitor, and I focused on integrating the **ACE** security monitor, isolating the Linux kernel from the firmware, and resuming development on **Virt-Sail**.\\n\\n### ACE - secure the confidential virtual machines!\\n\\nACE is a security monitor for confidential virtual machines, built on the [CoVE specification](https://github.com/riscv-non-isa/riscv-ap-tee) presented at a workshop by IBM Research. Currently, ACE operates alongside **OpenSBI** and requires the firmware to be part of the root of trust.\\n\\nI developed a demonstration showcasing how the ACE security monitor can be collocated with **Miralis**. The process began with emulating the hypervisor extension in Miralis, which ACE requires. The most challenging and interesting aspect was merging the two security monitors. \\n\\nThe architecture is based on the following principle:\\n- When the firmware is running, **Miralis** serves as the security monitor responsible for handling security operations.  \\n- When the payload or confidential virtual machines are active, **ACE** becomes the active security monitor.  \\n\\nA \\"monitor context switch\\" is performed during transitions between the firmware and payload, transferring control of the system from one security monitor to the other. After a few intense debugging sessions with **GDB**, ACE is now able to launch a confidential virtual machine with a virtual firmware monitor. Success! \ud83c\udf89\\n\\n### Keystone - secure the confidential enclave!\\n\\nThe second policy, simply named the \\"Keystone Policy,\\" is a rust reimplementation of the open-source [Keystone framework](https://keystone-enclave.org/). The **Keystone security monitor** provides a Trusted Execution Environment (TEE) framework for RISC-V platforms and its primary goal is to enable the secure and isolated execution of user applications (enclaves) while protecting them from malicious software, untrusted operating systems, or even hypervisors\\n\\nFr\xe9d\xe9ric reimplemented Keystone in **Rust** and adapted it into a policy that works seamlessly with **Miralis**. He is currently fixing the last few issues.\\n\\n### Strict protect payload - secure the linux kernel!\\n\\nLast but not least, in a more general case, we aim to isolate the Linux kernel from untrusted firmware. The final policy we present here is the **Protect Payload** policy.  \\n\\nThis policy is the smallest of the three and is responsible for isolating the firmware from the operating system. The firmware can no longer access the payload\u2019s memory, thanks to PMP entries, and registers are cleared between each world switch, except for registers `a0-a7`, which are preserved for `ecalls`. Additionally, we implemented an attestation mechanism to verify that the firmware properly loads the payload before jumping to it.  \\n\\nOn the hardware side, we also had to implement emulation for misaligned loads and stores since we can no longer rely on OpenSBI for this functionality. Currently, we can boot Linux kernels for Fedora, openSUSE, and Ubuntu (in recovery mode), with the OS memory isolated from the firmware.\\n\\n## Virt-sail - verify the hypervisor!\\n\\nIn the KISV paper, we presented an initial draft for formally verifying the **MRET** instruction. We have since revisited this project and are now developing a transpiler capable of translating the instructions that _virt.rs_ aims to emulate. An example is shown below, and the source code (currently under development) [is available here](https://github.com/CharlyCst/virt-sail).\\n\\n```rust\\n#![allow(unused, non_snake_case, non_upper_case_globals, non_camel_case_types, bindings_with_variant_name)]\\n\\nuse sail_prelude::*;\\n\\nconst xlen: usize = 64;\\nconst xlen_bytes: usize = 8;\\n\\ntype xlenbits = BitVector<xlen>;\\ntype priv_level = BitVector<2>;\\ntype regidx = BitVector<5>;\\ntype cregidx = BitVector<3>;\\ntype csreg = BitVector<12>;\\ntype Mstatus = BitVector<64>;\\n\\nstruct SailVirtCtx {\\n    PC: xlenbits,\\n    nextPC: xlenbits,\\n    mepc: xlenbits,\\n    sepc: xlenbits,\\n    uepc: xlenbits,\\n    mstatus: Mstatus,\\n    cur_privilege: Privilege,\\n    Xs: [xlenbits;32],\\n}\\n\\n#[derive(Eq, PartialEq, Clone, Copy, Debug)]\\nenum Privilege {\\n    User,\\n    Supervisor,\\n    Machine,\\n}\\n\\nfn haveUsrMode(sail_ctx: &mut SailVirtCtx) -> bool {\\n    true\\n}\\n\\nfn privLevel_to_bits(sail_ctx: &mut SailVirtCtx, p: Privilege) -> BitVector<2> {\\n    match p {\\n        Privilege::User => {BitVector::new(0b00)}\\n        Privilege::Supervisor => {BitVector::new(0b01)}\\n        Privilege::Machine => {BitVector::new(0b11)}\\n    }\\n}\\n\\nfn privLevel_of_bits(sail_ctx: &mut SailVirtCtx, p: BitVector<2>) -> Privilege {\\n    match p {\\n        b__0 if (b__0 == BitVector::new(0b00)) => {Privilege::User}\\n        b__1 if (b__1 == BitVector::new(0b01)) => {Privilege::Supervisor}\\n        b__2 if (b__2 == BitVector::new(0b11)) => {Privilege::Machine}\\n        _ => {not_implemented(String::from(\\"Invalid privilege level\\"))}\\n    }\\n}\\n\\nfn pc_alignment_mask(sail_ctx: &mut SailVirtCtx) -> BitVector<64> {\\n    !(BitVector::<64>::new(BitVector::new(0b10).bits()))\\n}\\n\\nfn _get_Mstatus_MPIE(sail_ctx: &mut SailVirtCtx, v: Mstatus) -> BitVector<1> {\\n    v.subrange::<7, 8, 1>()\\n}\\n\\nfn _get_Mstatus_MPP(sail_ctx: &mut SailVirtCtx, v: Mstatus) -> BitVector<2> {\\n    v.subrange::<11, 13, 2>()\\n}\\n\\nfn set_next_pc(sail_ctx: &mut SailVirtCtx, pc: BitVector<64>) {\\n    sail_ctx.nextPC = pc\\n}\\n\\nfn handle_illegal(sail_ctx: &mut SailVirtCtx) {\\n    \\n}\\n\\nfn get_xret_target(sail_ctx: &mut SailVirtCtx, p: Privilege) -> BitVector<64> {\\n    match p {\\n        Privilege::Machine => {sail_ctx.mepc}\\n        Privilege::Supervisor => {sail_ctx.sepc}\\n        Privilege::User => {sail_ctx.uepc}\\n    }\\n}\\n\\nfn prepare_xret_target(sail_ctx: &mut SailVirtCtx, p: Privilege) -> BitVector<64> {\\n    get_xret_target(sail_ctx, p)\\n}\\n\\nfn exception_handler(sail_ctx: &mut SailVirtCtx, cur_priv: Privilege, pc: BitVector<64>) -> BitVector<64> {\\n    let prev_priv = sail_ctx.cur_privilege;\\n    sail_ctx.mstatus = {\\n        let var_1 = _get_Mstatus_MPIE(sail_ctx, sail_ctx.mstatus);\\n        sail_ctx.mstatus.set_subrange::<3, 4, 1>(var_1)\\n    };\\n    sail_ctx.mstatus = sail_ctx.mstatus.set_subrange::<7, 8, 1>(BitVector::new(0b1));\\n    sail_ctx.cur_privilege = {\\n        let var_2 = _get_Mstatus_MPP(sail_ctx, sail_ctx.mstatus);\\n        privLevel_of_bits(sail_ctx, var_2)\\n    };\\n    sail_ctx.mstatus = {\\n        let var_3 = {\\n            let var_4 = if haveUsrMode(sail_ctx) {\\n                Privilege::User\\n            } else {\\n                Privilege::Machine\\n            };\\n            privLevel_to_bits(sail_ctx, var_4)\\n        };\\n        sail_ctx.mstatus.set_subrange::<11, 13, 2>(var_3)\\n    };\\n    if (sail_ctx.cur_privilege != Privilege::Machine) {\\n        sail_ctx.mstatus = sail_ctx.mstatus.set_subrange::<17, 18, 1>(BitVector::new(0b0))\\n    } else {\\n        \\n    };\\n    (prepare_xret_target(sail_ctx, Privilege::Machine) & pc_alignment_mask(sail_ctx))\\n}\\n\\n#[derive(Eq, PartialEq, Clone, Copy, Debug)]\\nenum Retired {\\n    RETIRE_SUCCESS,\\n    RETIRE_FAIL,\\n}\\n\\n#[derive(Eq, PartialEq, Clone, Copy, Debug)]\\nenum ast {\\n    MRET(),\\n}\\n\\nfn ext_check_xret_priv(sail_ctx: &mut SailVirtCtx, p: Privilege) -> bool {\\n    true\\n}\\n\\nfn ext_fail_xret_priv(sail_ctx: &mut SailVirtCtx) {\\n    \\n}\\n\\nfn execute_MRET(sail_ctx: &mut SailVirtCtx, TodoArgsApp: TodoUnsupportedUnionSignature) {\\n    if (sail_ctx.cur_privilege != Privilege::Machine) {\\n        handle_illegal(sail_ctx);\\n        Retired::RETIRE_FAIL\\n    } else if !(ext_check_xret_priv(sail_ctx, Privilege::Machine)) {\\n        ext_fail_xret_priv(sail_ctx);\\n        Retired::RETIRE_FAIL\\n    } else {\\n        {\\n            let var_5 = exception_handler(sail_ctx, sail_ctx.cur_privilege, sail_ctx.PC);\\n            set_next_pc(sail_ctx, var_5)\\n        };\\n        Retired::RETIRE_SUCCESS\\n    }\\n}\\n\\n```\\n\\n## Next steps\\n\\nWe are currently facing some issues with the graphical interface that we plan to fix. We\'ll start by resolving this issue, followed by running benchmarks on the board to accurately measure the overhead under real-world conditions. Afterward, we will complete Virt-sail and add formal verification to the CI/CD tests to formally validate _virt.rs_, the part of the implementation responsible for emulating the virtual firmware. \\n\\nMeanwhile, Charly is working on formalizing the definition of the firmware monitor using a theorem prover to extend the criteria set by [Popek and Goldberg](https://en.wikipedia.org/wiki/Popek_and_Goldberg_virtualization_requirements). On his end, Fr\xe9d\xe9ric is focused on completing the integration of Keystone on the board."},{"id":"summer-2024-progress-report","metadata":{"permalink":"/blog/summer-2024-progress-report","source":"@site/blog/2024-09-29-summer-2024-progress.md","title":"Summer 2024 progress report","description":"Three months and 110 commits after the open-sourcing of Miralis we have come a long way, and now sounds like a good time for our first ever progress report.","date":"2024-09-29T00:00:00.000Z","tags":[{"inline":false,"label":"News","permalink":"/blog/tags/news","description":"News and updates about Miralis"}],"readingTime":6.27,"hasTruncateMarker":true,"authors":[{"name":"Charly Castes","description":"PhD candidate at EPFL, focusing on system security.","page":{"permalink":"/blog/authors/charlycst"},"socials":{"x":"https://x.com/CharlyCastes","github":"https://github.com/CharlyCst","website":"https://charlycst.github.io"},"imageURL":"https://github.com/charlycst.png","key":"charlycst"}],"frontMatter":{"slug":"summer-2024-progress-report","title":"Summer 2024 progress report","authors":["charlycst"],"tags":["news"]},"unlisted":false,"lastUpdatedAt":1727630422000,"prevItem":{"title":"Fall 2024 progress report","permalink":"/blog/end-2024-progress-report"},"nextItem":{"title":"Hello, world!","permalink":"/blog/hello-world"}},"content":"Three months and 110 commits after the [open-sourcing of Miralis](https://github.com/CharlyCst/miralis) we have come a long way, and now sounds like a good time for our first ever progress report.\\nThis summer we had the chance to host Sofia and No\xe9 at the lab, they both have been doing stellar work and Miralis would be nowhere close to where it is today without them, so kudos to both of them, it has really been a pleasure to work together!\\n\\n\x3c!--truncate--\x3e\\n\\n## Miralis in a nutshell\\n\\nMiralis is the first implementation of what we call a **virtual firmware monitor**, or VFM for short.\\nA VFM is a system that virtualizes the firmware privilege mode, similar to how software-based hypervisors can virtualize the kernel mode.\\nMiralis is written in Rust and targets RISC-V platforms, it can run unmodified de-privileged firmware in U-mode, which we call virtual M-mode or vM-mode for short.\\nThe purpose of Miralis is to protect sensitive workloads from potentially untrusted firmware, a thorny problem especially in the era of confidential computing and trusted execution environments.\\n\\n## Summer 2024\\n\\nOver the summer we focused on two major milestones: **full Linux support** and **porting Miralis to the VisionFive 2 board**.\\nWhile we need to polish out a few rough edges, I think we can say that we delivered on both objectives.\\nAs a bonus thanks to the great work of Sofia and No\xe9 we even managed to submit a first paper that got accepted to the [KISV 2024 workshop](https://kisv-workshop.github.io/), the final version will be published soon (Yay! \ud83e\udd73).\\n\\n### Full Linux support\\n\\nThis summer we achieved full Linux support on QEMU, which means that Linux can run seamlessly with a virtualized OpenSBI.\\nWhen running an Operating system along with a virtualized firmware with Miralis the deployment looks like this:\\n\\n```\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\nU-mode  \u2502             \u2502 \u2502  OpenSBI  \u2502 vM-mode\\n        \u2502    Linux    \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\nS-mode  \u2502             \u2502\\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\nM-mode  \u2502          Miralis          \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n```\\n\\nAn important note is that Miralis only virtualizes the firmware, which means that the OS (both the Linux kernel and user-space applications) executes natively at full speed until it traps to the firmware, at which point Miralis triggers a world switch toward the virtualized M-mode.\\nThis is similar to software-based virtual machine monitors that pre-dates hardware virtualization extensions, such as the [original VMWare Workstation](https://dl.acm.org/doi/abs/10.1145/2382553.2382554?casa_token=Lm-qUMZ5qmEAAAAA:B_O-hl8qBIMBN2xXD-cnlH3GU0Js8yUAsVfAH-O2zPz1t8VTAM2A-D9qRC7fT8ucoRNyNK_hI2Knr24).\\nThose VMMs run user-space applications natively but switch to an efficient virtualized mode for kernel code execution.\\nMiralis is heavily inspired by those early designs, but virtualizes the firmware rather than the kernel.\\n\\nThe interesting bits here is that neither OpenSBI nor Linux need to be modified to run with Miralis.\\nThis works without re-compilation because both of them are position independent, but even for non-position independent software we would not need to change the source code (beside the base address if hardcoded) because RISC-V has the nice property of being a virtualizable architecture.\\nThis is very important for us, as we want to provide full backward-compatibility with Miralis.\\n\\nThe main challenge in getting Linux to work properly is interrupt virtualization.\\nWhile we mostly had to handle M-mode timer interrupts before, Linux virtualization requires proper handling of all kinds of interrupts.\\nThe trickiest one was the supervisor external interrupt (`SEI`), which has a different semantic than other interrupt bits: there is not one, but two `SEI` bits, one writable by the hardware, the other by the software, but software can only read the binary `OR` of those two bits.\\n\\nWe now reached a point where Linux runs smoothly on top of Miralis on the QEMU platform.\\nWe tested with both a small BusyBox-based user-space (which we now run against each pull requests in the CI) and a full ubuntu distribution.\\nRunning Linux on Miralis is now as simple as executing `just run linux-shell`.\\n\\n### Porting Miralis to the VisionFive 2\\n\\nOur second milestone is porting Miralis to the VisionFive 2 board.\\nThe VisionFive 2 features a JH7110 SoC, with a quad-core SiFive U74 (RV64GC) processor plus one smaller SiFive S7 (RV64IMAC) monitor core.\\nThe feature set of the VisionFive 2 is quite different from what QEMU exposes, which rose quite a few challenges.\\n\\nThe first challenge with the VisionFive 2 was multi-core support.\\nNot only is the JH7110 a multi-core platform, but it is also heterogeneous.\\nThe smaller SiFive S7 core does not support S-mode, for instance, and has some more restrictions we had to take into account.\\nWe added proper multi-core support to Miralis, which required carefully re-designing the initialization sequence and boot assembly to setup disjoint stacks and initialize global resources such as zeroing-out the `.bss` section.\\n\\nAnother interesting part is how to insert Miralis in the boot chain.\\nWhen the VisionFive 2 boot it starts executing a small read-only bootstrap code, the reset vector, which then jumps to the first writable executable memory.\\nThe vendor-provided software boots like this: reset-vector -> u-boot SPL -> OpenSBI -> u-boot proper -> Linux.\\nThe first run-time resident firmware in the boot chain is OpenSBI, the role of u-boot SPL is mostly to initialize DRAM and transfer control to the next stage but it does not stay active at run time.\\nWe decided to insert Miralis after u-boot SPL, and then transfer control to OpenSBI in the virtual M-mode.\\nThat way Miralis is the only M-mode software present at runtime, as OpenSBI runs deprivileged.\\n\\nFinally the VisionFive 2 has a more limited set of hardware features compared to QEMU.\\nOne major difference, for instance, is the lack of support for misaligned reads and writes.\\nOn the VisionFive 2 misaligned reads and writes from the kernel are emulated by OpenSBI by changing the memory access privilege (the using the `MPRV` bit in `mstatus`).\\nThe `MPRV` bit allow M-mode software to read and write memory as if it was executing with S or U-mode privilege (but instruction fetches keep using M-mode privileges), which simplifies accessing OS memory by removing the need for software page table walk and permission checks.\\nHowever the `MPRV` bit can\'t be enabled while running virtualized firmware with Miralis as the firmware already executes in U-mode.\\nWe emulated the `MPRV` bit in Miralis by forcing traps from the firmware to Miralis during reads and writes when the virtual `MPRV` is set to 1, which enables Miralis to emulate the read or write using S or U-mode privileges using the physical `MPRV` bit.\\nThere are other differences between QEMU and the VisionFive 2, in particular around devices, but we already managed to close most of the gaps.\\n\\n## What is next\\n\\nWith the start of the new academic semester Fran\xe7ois and Fr\xe9d\xe9ric are joining forces to work on Miralis.\\nOur objectives for the next few months is to demonstrate how to **enforce security policies with Miralis**.\\nBy default Miralis grants (almost) full access to the machine to the virtualized firmware, therefore it does not provide any security guarantee _per se_.\\nThere can be many desirable isolation policies, therefore Miralis does not try to provide the \'one true\' security policy, but our goal is rather to enable the implementation of many custom policies.\\nFor instance it might be desirable to isolate confidential VMs or enclaves from the firmware and host OS, or even the whole host OS form the firmware.\\n\\nOverall I am very enthusiastic about Miralis, the project has already gone a long way and built up a very good momentum.\\nThere is still a lot on our plate to achieve our vision of securing the lowest layer of the software stack, but I am confident we will get there."},{"id":"hello-world","metadata":{"permalink":"/blog/hello-world","source":"@site/blog/2024-07-01-hello-world.md","title":"Hello, world!","description":"I am glad to announce that today we open-sourced Miralis, a project I have been working on for the last six months together with some awesome people!","date":"2024-07-01T00:00:00.000Z","tags":[{"inline":false,"label":"News","permalink":"/blog/tags/news","description":"News and updates about Miralis"}],"readingTime":4.295,"hasTruncateMarker":true,"authors":[{"name":"Charly Castes","description":"PhD candidate at EPFL, focusing on system security.","page":{"permalink":"/blog/authors/charlycst"},"socials":{"x":"https://x.com/CharlyCastes","github":"https://github.com/CharlyCst","website":"https://charlycst.github.io"},"imageURL":"https://github.com/charlycst.png","key":"charlycst"}],"frontMatter":{"slug":"hello-world","title":"Hello, world!","authors":["charlycst"],"tags":["news"]},"unlisted":false,"lastUpdatedAt":1727630422000,"prevItem":{"title":"Summer 2024 progress report","permalink":"/blog/summer-2024-progress-report"}},"content":"I am glad to announce that today we open-sourced [Miralis](https://github.com/charlycst/miralis), a project I have been working on for the last six months together with some awesome people!\\nWe are still in the very early days, but I think we already built something quite interesting, and I am looking forward to continue developing Miralis in the open.\\n\\n\x3c!--truncate--\x3e\\n\\n## The Achilles\' heel of the compute infrastructure\\n\\nThe Miralis project started from the realisation that modern computers are built on top of two incompatible assumptions at the lowest level of the stack: the computer\'s firmware.\\nOn one hand the firmware\'s responsibility is to manage and configure the hardware, it is often proprietary and presented as an opaque binary blob that needs to be installed on all machines.\\nOn the other hand, the firmware recently gained a new role as the entity that enforces machine-wide security policies.\\nThis is especially true with the rise of confidential computing (e.g. [ARM CCA](https://www.arm.com/architecture/security-features/arm-confidential-compute-architecture) or RISC-V\'s [Keystone](https://keystone-enclave.org/)), where the responsibility to provide isolation is shifted from the OS/hypervisor to the firmware.\\n\\nThe two roles of the firmware, managing the hardware and enforcing security policies, are fundamentally in tension with each other, or at least will be until hardware manufacturers agree to release the source of their firmware.\\nUntil then, the security of the world\'s compute infrastructure has no choice but to rely on opaque binary blobs.\\n\\nWith Miralis we would like to propose something different.\\nWe acknowledge the need for proprietary firmware but we do not want to rely on it for security.\\nRather, we propose to deprivilege proprietary firmware and to enforce strong isolation policies to decouple the security of the rest of the computing stack from the correctness (and cooperation) of opaque firmware.\\nWe understand that requiring firmware changes would be disruptive, therefore we propose to execute unmodified firmware by virtualising and sandboxing the lowest privilege level on the machine.\\n\\n## Miralis in a nutshell\\n\\nIn short Miralis is RISC-V security monitor that virtualises M-mode software.\\nBy \\"virtualise M-mode software\\" I mean that Miralis can run deprivileged M-mode software transparently, like it would execute on a bare metal RISC-V machine.\\nAs a quick summary for people new to RISC-V, the RISC-V architecture exposes up to three privilege modes (ignoring the hypervisor extension): user mode (U-mode, for applications), supervisor mode (S-mode, for the OS kernel), and machine mode (M-mode, for the firmware).\\n\\n```\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\nU-mode  \u2502   User App   \u2502\\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\nS-mode  \u2502      OS      \u2502\\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\nM-mode  \u2502   Firmware   \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n```\\n\\nWith Miralis we make it possible to execute firmware in a virtual M-mode.\\nIn practice we run the firmware in U-mode under the control of Miralis.\\nThis makes it possible to sandbox M-mode software, which how we protect the rest of the stack from untrusted firmware, while running the OS natively at full speed.\\n\\n```\\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\nU-mode  \u2502   User App   \u2502 \u2502  Firmware  \u2502\\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\nS-mode  \u2502      OS      \u2502\\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\nM-mode  \u2502           Miralis           \u2502\\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n```\\n\\nThe firmware is virtualised using a classical trap & emulate approach: most of the instructions are executed natively by the processor, but privileged instructions trap to Miralis which will emulate them in software (while enforcing security invariants).\\n\\n## Current status\\n\\nThe project started six months ago, slowly at first but we are now making progress at a steady pace.\\nThe initial focus was on the software architecture, to make the project modular and as future proof as we could anticipate.\\nThe main components of Miralis are in place.\\nThis include for instance the instruction decoder, instruction emulation, virtual contexts, and context switching.\\nThe code base is modular over the platform (to support multiple boards and SoCs in the future) and the architecture (to support, e.g., running Miralis in user-space for unit and integration testing).\\n\\nWe do not yet support a wide variety of workloads, but we do have a solid foundation.\\nMiralis can already boot an unmodified [OpenSBI](https://github.com/riscv-software-src/opensbi) in virtual M-mode (that is physical U-mode) with a simple payload. We also experimented with other firmware, such as [Zephyr](https://zephyrproject.org/) for which we have early support.\\n\\nI would like use this opportunity to thank all the people who contributed to the Miralis project, especially my awesome colleague Neelu who helped design Miralis, Abel who achieved a tremendous amount of work over the last semester and actually took Miralis to the place it is today, and Fran\xe7ois who recently joined the effort and made some great contributions.\\n\\n## What is next\\n\\nThis summer we will focus on delivering on the Miralis promises, in particular by focusing on full Linux support and porting Miralis to physical boards in addition to our current QEMU support.\\nWe will also explore new approaches to deliver best-in-class security, in particular through an innovative take a formally verifying crucial pieces of Miralis, a subject I would like to discuss more in the near future.\\n\\nOver the summer Sofia and No\xe9 will be joining forces, I\'m sure we will be able to achieve a lot by working together and I am looking forward to see how far we can go with Miralis, with the ultimate goal to help secure the foundations of the world\'s compute infrastructure."}]}}')}}]);