"use strict";(self.webpackChunkwebsite_miralis=self.webpackChunkwebsite_miralis||[]).push([[3080],{1982:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var n=i(4848),r=i(8453);const s={slug:"end-2024-progress-report",title:"Fall 2024 progress report",authors:["francois141"],tags:["news"]},a=void 0,o={permalink:"/blog/end-2024-progress-report",source:"@site/blog/2024-11-31-end-2024.md",title:"Fall 2024 progress report",description:"The year concludes with the addition of 300 commits to Miralis and successful deployment of Debian running securely on ACE with a policy that isolates the linux kernel from the OpenSBI firmware (see image below). We can run the classical commands There have been some changes in the composition of the Miralis team, Fr\xe9d\xe9ric and I are replacing Sofia and No\xe9. Additionally, we have open-sourced a second tool, Virt-Sail, a transpiler currently under development that converts Sail code into Rust.",date:"2024-12-01T00:00:00.000Z",tags:[{inline:!1,label:"News",permalink:"/blog/tags/news",description:"News and updates about Miralis"}],readingTime:5.725,hasTruncateMarker:!0,authors:[{name:"Fran\xe7ois Costa",description:"Low latency engineer at Mathrix.",page:{permalink:"/blog/authors/francois-141"},socials:{github:"https://github.com/francois141",website:"https://francois141.github.io"},imageURL:"https://github.com/francois141/francois141/blob/main/pictures/portrait1.jpg?raw=true",key:"francois141"}],frontMatter:{slug:"end-2024-progress-report",title:"Fall 2024 progress report",authors:["francois141"],tags:["news"]},unlisted:!1,lastUpdatedAt:17381509e5,nextItem:{title:"Summer 2024 progress report",permalink:"/blog/summer-2024-progress-report"}},l={authorsImageUrls:[void 0]},c=[{value:"3 new security policies",id:"3-new-security-policies",level:2},{value:"ACE - secure the confidential virtual machines!",id:"ace---secure-the-confidential-virtual-machines",level:3},{value:"Keystone - secure the confidential enclave!",id:"keystone---secure-the-confidential-enclave",level:3},{value:"Strict protect payload - secure the linux kernel!",id:"strict-protect-payload---secure-the-linux-kernel",level:3},{value:"Virt-sail - verify the hypervisor!",id:"virt-sail---verify-the-hypervisor",level:2},{value:"Next steps",id:"next-steps",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["The year concludes with the addition of 300 commits to ",(0,n.jsx)(t.strong,{children:"Miralis"})," and successful deployment of ",(0,n.jsx)(t.strong,{children:"Debian"})," running securely on ",(0,n.jsx)(t.strong,{children:"ACE"})," with a policy that isolates the linux kernel from the OpenSBI firmware (see image below). We can run the classical commands There have been some changes in the composition of the Miralis team, Fr\xe9d\xe9ric and I are replacing Sofia and No\xe9. Additionally, we have open-sourced a second tool, ",(0,n.jsx)(t.a,{href:"https://github.com/CharlyCst/virt-sail",children:(0,n.jsx)(t.strong,{children:"Virt-Sail"})}),", a transpiler currently under development that converts ",(0,n.jsx)(t.strong,{children:"Sail"})," code into ",(0,n.jsx)(t.strong,{children:"Rust"}),"."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"ACE demo with protect payload policy",src:i(9969).A+"",width:"4032",height:"1361"})}),"\n",(0,n.jsx)(t.h2,{id:"3-new-security-policies",children:"3 new security policies"}),"\n",(0,n.jsxs)(t.p,{children:["Building on the strong momentum established by Sofia and No\xe9, Charly, Fr\xe9d\xe9ric, and I have developed three security policies. Additionally, Miralis can now boot various Linux distributions, including Ubuntu, Fedora, OpenSUSE, and Debian. Charly focused on virtualizing interrupts, Fr\xe9d\xe9ric took responsibility for integrating the ",(0,n.jsx)(t.strong,{children:"Keystone"})," security monitor, and I focused on integrating the ",(0,n.jsx)(t.strong,{children:"ACE"})," security monitor, isolating the Linux kernel from the firmware, and resuming development on ",(0,n.jsx)(t.strong,{children:"Virt-Sail"}),"."]}),"\n",(0,n.jsx)(t.h3,{id:"ace---secure-the-confidential-virtual-machines",children:"ACE - secure the confidential virtual machines!"}),"\n",(0,n.jsxs)(t.p,{children:["ACE is a security monitor for confidential virtual machines, built on the ",(0,n.jsx)(t.a,{href:"https://github.com/riscv-non-isa/riscv-ap-tee",children:"CoVE specification"})," presented at a workshop by IBM Research. Currently, ACE operates alongside ",(0,n.jsx)(t.strong,{children:"OpenSBI"})," and requires the firmware to be part of the root of trust."]}),"\n",(0,n.jsxs)(t.p,{children:["I developed a demonstration showcasing how the ACE security monitor can be collocated with ",(0,n.jsx)(t.strong,{children:"Miralis"}),". The process began with emulating the hypervisor extension in Miralis, which ACE requires. The most challenging and interesting aspect was merging the two security monitors."]}),"\n",(0,n.jsx)(t.p,{children:"The architecture is based on the following principle:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["When the firmware is running, ",(0,n.jsx)(t.strong,{children:"Miralis"})," serves as the security monitor responsible for handling security operations."]}),"\n",(0,n.jsxs)(t.li,{children:["When the payload or confidential virtual machines are active, ",(0,n.jsx)(t.strong,{children:"ACE"})," becomes the active security monitor."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:['A "monitor context switch" is performed during transitions between the firmware and payload, transferring control of the system from one security monitor to the other. After a few intense debugging sessions with ',(0,n.jsx)(t.strong,{children:"GDB"}),", ACE is now able to launch a confidential virtual machine with a virtual firmware monitor. Success! \ud83c\udf89"]}),"\n",(0,n.jsx)(t.h3,{id:"keystone---secure-the-confidential-enclave",children:"Keystone - secure the confidential enclave!"}),"\n",(0,n.jsxs)(t.p,{children:['The second policy, simply named the "Keystone Policy," is a rust reimplementation of the open-source ',(0,n.jsx)(t.a,{href:"https://keystone-enclave.org/",children:"Keystone framework"}),". The ",(0,n.jsx)(t.strong,{children:"Keystone security monitor"})," provides a Trusted Execution Environment (TEE) framework for RISC-V platforms and its primary goal is to enable the secure and isolated execution of user applications (enclaves) while protecting them from malicious software, untrusted operating systems, or even hypervisors"]}),"\n",(0,n.jsxs)(t.p,{children:["Fr\xe9d\xe9ric reimplemented Keystone in ",(0,n.jsx)(t.strong,{children:"Rust"})," and adapted it into a policy that works seamlessly with ",(0,n.jsx)(t.strong,{children:"Miralis"}),". He is currently fixing the last few issues."]}),"\n",(0,n.jsx)(t.h3,{id:"strict-protect-payload---secure-the-linux-kernel",children:"Strict protect payload - secure the linux kernel!"}),"\n",(0,n.jsxs)(t.p,{children:["Last but not least, in a more general case, we aim to isolate the Linux kernel from untrusted firmware. The final policy we present here is the ",(0,n.jsx)(t.strong,{children:"Protect Payload"})," policy."]}),"\n",(0,n.jsxs)(t.p,{children:["This policy is the smallest of the three and is responsible for isolating the firmware from the operating system. The firmware can no longer access the payload\u2019s memory, thanks to PMP entries, and registers are cleared between each world switch, except for registers ",(0,n.jsx)(t.code,{children:"a0-a7"}),", which are preserved for ",(0,n.jsx)(t.code,{children:"ecalls"}),". Additionally, we implemented an attestation mechanism to verify that the firmware properly loads the payload before jumping to it."]}),"\n",(0,n.jsx)(t.p,{children:"On the hardware side, we also had to implement emulation for misaligned loads and stores since we can no longer rely on OpenSBI for this functionality. Currently, we can boot Linux kernels for Fedora, openSUSE, and Ubuntu (in recovery mode), with the OS memory isolated from the firmware."}),"\n",(0,n.jsx)(t.h2,{id:"virt-sail---verify-the-hypervisor",children:"Virt-sail - verify the hypervisor!"}),"\n",(0,n.jsxs)(t.p,{children:["In the KISV paper, we presented an initial draft for formally verifying the ",(0,n.jsx)(t.strong,{children:"MRET"})," instruction. We have since revisited this project and are now developing a transpiler capable of translating the instructions that ",(0,n.jsx)(t.em,{children:"virt.rs"})," aims to emulate. An example is shown below, and the source code (currently under development) ",(0,n.jsx)(t.a,{href:"https://github.com/CharlyCst/virt-sail",children:"is available here"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:'#![allow(unused, non_snake_case, non_upper_case_globals, non_camel_case_types, bindings_with_variant_name)]\n\nuse sail_prelude::*;\n\nconst xlen: usize = 64;\nconst xlen_bytes: usize = 8;\n\ntype xlenbits = BitVector<xlen>;\ntype priv_level = BitVector<2>;\ntype regidx = BitVector<5>;\ntype cregidx = BitVector<3>;\ntype csreg = BitVector<12>;\ntype Mstatus = BitVector<64>;\n\nstruct SailVirtCtx {\n    PC: xlenbits,\n    nextPC: xlenbits,\n    mepc: xlenbits,\n    sepc: xlenbits,\n    uepc: xlenbits,\n    mstatus: Mstatus,\n    cur_privilege: Privilege,\n    Xs: [xlenbits;32],\n}\n\n#[derive(Eq, PartialEq, Clone, Copy, Debug)]\nenum Privilege {\n    User,\n    Supervisor,\n    Machine,\n}\n\nfn haveUsrMode(sail_ctx: &mut SailVirtCtx) -> bool {\n    true\n}\n\nfn privLevel_to_bits(sail_ctx: &mut SailVirtCtx, p: Privilege) -> BitVector<2> {\n    match p {\n        Privilege::User => {BitVector::new(0b00)}\n        Privilege::Supervisor => {BitVector::new(0b01)}\n        Privilege::Machine => {BitVector::new(0b11)}\n    }\n}\n\nfn privLevel_of_bits(sail_ctx: &mut SailVirtCtx, p: BitVector<2>) -> Privilege {\n    match p {\n        b__0 if (b__0 == BitVector::new(0b00)) => {Privilege::User}\n        b__1 if (b__1 == BitVector::new(0b01)) => {Privilege::Supervisor}\n        b__2 if (b__2 == BitVector::new(0b11)) => {Privilege::Machine}\n        _ => {not_implemented(String::from("Invalid privilege level"))}\n    }\n}\n\nfn pc_alignment_mask(sail_ctx: &mut SailVirtCtx) -> BitVector<64> {\n    !(BitVector::<64>::new(BitVector::new(0b10).bits()))\n}\n\nfn _get_Mstatus_MPIE(sail_ctx: &mut SailVirtCtx, v: Mstatus) -> BitVector<1> {\n    v.subrange::<7, 8, 1>()\n}\n\nfn _get_Mstatus_MPP(sail_ctx: &mut SailVirtCtx, v: Mstatus) -> BitVector<2> {\n    v.subrange::<11, 13, 2>()\n}\n\nfn set_next_pc(sail_ctx: &mut SailVirtCtx, pc: BitVector<64>) {\n    sail_ctx.nextPC = pc\n}\n\nfn handle_illegal(sail_ctx: &mut SailVirtCtx) {\n    \n}\n\nfn get_xret_target(sail_ctx: &mut SailVirtCtx, p: Privilege) -> BitVector<64> {\n    match p {\n        Privilege::Machine => {sail_ctx.mepc}\n        Privilege::Supervisor => {sail_ctx.sepc}\n        Privilege::User => {sail_ctx.uepc}\n    }\n}\n\nfn prepare_xret_target(sail_ctx: &mut SailVirtCtx, p: Privilege) -> BitVector<64> {\n    get_xret_target(sail_ctx, p)\n}\n\nfn exception_handler(sail_ctx: &mut SailVirtCtx, cur_priv: Privilege, pc: BitVector<64>) -> BitVector<64> {\n    let prev_priv = sail_ctx.cur_privilege;\n    sail_ctx.mstatus = {\n        let var_1 = _get_Mstatus_MPIE(sail_ctx, sail_ctx.mstatus);\n        sail_ctx.mstatus.set_subrange::<3, 4, 1>(var_1)\n    };\n    sail_ctx.mstatus = sail_ctx.mstatus.set_subrange::<7, 8, 1>(BitVector::new(0b1));\n    sail_ctx.cur_privilege = {\n        let var_2 = _get_Mstatus_MPP(sail_ctx, sail_ctx.mstatus);\n        privLevel_of_bits(sail_ctx, var_2)\n    };\n    sail_ctx.mstatus = {\n        let var_3 = {\n            let var_4 = if haveUsrMode(sail_ctx) {\n                Privilege::User\n            } else {\n                Privilege::Machine\n            };\n            privLevel_to_bits(sail_ctx, var_4)\n        };\n        sail_ctx.mstatus.set_subrange::<11, 13, 2>(var_3)\n    };\n    if (sail_ctx.cur_privilege != Privilege::Machine) {\n        sail_ctx.mstatus = sail_ctx.mstatus.set_subrange::<17, 18, 1>(BitVector::new(0b0))\n    } else {\n        \n    };\n    (prepare_xret_target(sail_ctx, Privilege::Machine) & pc_alignment_mask(sail_ctx))\n}\n\n#[derive(Eq, PartialEq, Clone, Copy, Debug)]\nenum Retired {\n    RETIRE_SUCCESS,\n    RETIRE_FAIL,\n}\n\n#[derive(Eq, PartialEq, Clone, Copy, Debug)]\nenum ast {\n    MRET(),\n}\n\nfn ext_check_xret_priv(sail_ctx: &mut SailVirtCtx, p: Privilege) -> bool {\n    true\n}\n\nfn ext_fail_xret_priv(sail_ctx: &mut SailVirtCtx) {\n    \n}\n\nfn execute_MRET(sail_ctx: &mut SailVirtCtx, TodoArgsApp: TodoUnsupportedUnionSignature) {\n    if (sail_ctx.cur_privilege != Privilege::Machine) {\n        handle_illegal(sail_ctx);\n        Retired::RETIRE_FAIL\n    } else if !(ext_check_xret_priv(sail_ctx, Privilege::Machine)) {\n        ext_fail_xret_priv(sail_ctx);\n        Retired::RETIRE_FAIL\n    } else {\n        {\n            let var_5 = exception_handler(sail_ctx, sail_ctx.cur_privilege, sail_ctx.PC);\n            set_next_pc(sail_ctx, var_5)\n        };\n        Retired::RETIRE_SUCCESS\n    }\n}\n\n'})}),"\n",(0,n.jsx)(t.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,n.jsxs)(t.p,{children:["We are currently facing some issues with the graphical interface that we plan to fix. We'll start by resolving this issue, followed by running benchmarks on the board to accurately measure the overhead under real-world conditions. Afterward, we will complete Virt-sail and add formal verification to the CI/CD tests to formally validate ",(0,n.jsx)(t.em,{children:"virt.rs"}),", the part of the implementation responsible for emulating the virtual firmware."]}),"\n",(0,n.jsxs)(t.p,{children:["Meanwhile, Charly is working on formalizing the definition of the firmware monitor using a theorem prover to extend the criteria set by ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Popek_and_Goldberg_virtualization_requirements",children:"Popek and Goldberg"}),". On his end, Fr\xe9d\xe9ric is focused on completing the integration of Keystone on the board."]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},9969:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/board_demo-1599055d4735f7f808fb55520cdb9a4b.jpeg"},8453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>o});var n=i(6540);const r={},s=n.createContext(r);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);