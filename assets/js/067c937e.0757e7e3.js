"use strict";(self.webpackChunkwebsite_miralis=self.webpackChunkwebsite_miralis||[]).push([[8747],{6303:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>n,default:()=>c,frontMatter:()=>o,metadata:()=>a,toc:()=>h});var r=i(4848),s=i(8453);const o={slug:"summer-2024-progress-report",title:"Summer 2024 progress report",authors:["charlycst"],tags:["news"]},n=void 0,a={permalink:"/blog/summer-2024-progress-report",source:"@site/blog/2024-09-29-summer-2024-progress.md",title:"Summer 2024 progress report",description:"Three months and 110 commits after the open-sourcing of Miralis we have come a long way, and now sounds like a good time for our first ever progress report.",date:"2024-09-29T00:00:00.000Z",tags:[{inline:!1,label:"News",permalink:"/blog/tags/news",description:"News and updates about Miralis"}],readingTime:6.27,hasTruncateMarker:!0,authors:[{name:"Charly Castes",description:"PhD candidate at EPFL, focusing on system security.",page:{permalink:"/blog/authors/charlycst"},socials:{x:"https://x.com/CharlyCastes",github:"https://github.com/CharlyCst",website:"https://charlycst.github.io"},imageURL:"https://github.com/charlycst.png",key:"charlycst"}],frontMatter:{slug:"summer-2024-progress-report",title:"Summer 2024 progress report",authors:["charlycst"],tags:["news"]},unlisted:!1,lastUpdatedAt:1727630422e3,prevItem:{title:"Fall 2024 progress report",permalink:"/blog/end-2024-progress-report"},nextItem:{title:"Hello, world!",permalink:"/blog/hello-world"}},l={authorsImageUrls:[void 0]},h=[{value:"Miralis in a nutshell",id:"miralis-in-a-nutshell",level:2},{value:"Summer 2024",id:"summer-2024",level:2},{value:"Full Linux support",id:"full-linux-support",level:3},{value:"Porting Miralis to the VisionFive 2",id:"porting-miralis-to-the-visionfive-2",level:3},{value:"What is next",id:"what-is-next",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["Three months and 110 commits after the ",(0,r.jsx)(t.a,{href:"https://github.com/CharlyCst/miralis",children:"open-sourcing of Miralis"})," we have come a long way, and now sounds like a good time for our first ever progress report.\nThis summer we had the chance to host Sofia and No\xe9 at the lab, they both have been doing stellar work and Miralis would be nowhere close to where it is today without them, so kudos to both of them, it has really been a pleasure to work together!"]}),"\n",(0,r.jsx)(t.h2,{id:"miralis-in-a-nutshell",children:"Miralis in a nutshell"}),"\n",(0,r.jsxs)(t.p,{children:["Miralis is the first implementation of what we call a ",(0,r.jsx)(t.strong,{children:"virtual firmware monitor"}),", or VFM for short.\nA VFM is a system that virtualizes the firmware privilege mode, similar to how software-based hypervisors can virtualize the kernel mode.\nMiralis is written in Rust and targets RISC-V platforms, it can run unmodified de-privileged firmware in U-mode, which we call virtual M-mode or vM-mode for short.\nThe purpose of Miralis is to protect sensitive workloads from potentially untrusted firmware, a thorny problem especially in the era of confidential computing and trusted execution environments."]}),"\n",(0,r.jsx)(t.h2,{id:"summer-2024",children:"Summer 2024"}),"\n",(0,r.jsxs)(t.p,{children:["Over the summer we focused on two major milestones: ",(0,r.jsx)(t.strong,{children:"full Linux support"})," and ",(0,r.jsx)(t.strong,{children:"porting Miralis to the VisionFive 2 board"}),".\nWhile we need to polish out a few rough edges, I think we can say that we delivered on both objectives.\nAs a bonus thanks to the great work of Sofia and No\xe9 we even managed to submit a first paper that got accepted to the ",(0,r.jsx)(t.a,{href:"https://kisv-workshop.github.io/",children:"KISV 2024 workshop"}),", the final version will be published soon (Yay! \ud83e\udd73)."]}),"\n",(0,r.jsx)(t.h3,{id:"full-linux-support",children:"Full Linux support"}),"\n",(0,r.jsx)(t.p,{children:"This summer we achieved full Linux support on QEMU, which means that Linux can run seamlessly with a virtualized OpenSBI.\nWhen running an Operating system along with a virtualized firmware with Miralis the deployment looks like this:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nU-mode  \u2502             \u2502 \u2502  OpenSBI  \u2502 vM-mode\n        \u2502    Linux    \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nS-mode  \u2502             \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nM-mode  \u2502          Miralis          \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsxs)(t.p,{children:["An important note is that Miralis only virtualizes the firmware, which means that the OS (both the Linux kernel and user-space applications) executes natively at full speed until it traps to the firmware, at which point Miralis triggers a world switch toward the virtualized M-mode.\nThis is similar to software-based virtual machine monitors that pre-dates hardware virtualization extensions, such as the ",(0,r.jsx)(t.a,{href:"https://dl.acm.org/doi/abs/10.1145/2382553.2382554?casa_token=Lm-qUMZ5qmEAAAAA:B_O-hl8qBIMBN2xXD-cnlH3GU0Js8yUAsVfAH-O2zPz1t8VTAM2A-D9qRC7fT8ucoRNyNK_hI2Knr24",children:"original VMWare Workstation"}),".\nThose VMMs run user-space applications natively but switch to an efficient virtualized mode for kernel code execution.\nMiralis is heavily inspired by those early designs, but virtualizes the firmware rather than the kernel."]}),"\n",(0,r.jsx)(t.p,{children:"The interesting bits here is that neither OpenSBI nor Linux need to be modified to run with Miralis.\nThis works without re-compilation because both of them are position independent, but even for non-position independent software we would not need to change the source code (beside the base address if hardcoded) because RISC-V has the nice property of being a virtualizable architecture.\nThis is very important for us, as we want to provide full backward-compatibility with Miralis."}),"\n",(0,r.jsxs)(t.p,{children:["The main challenge in getting Linux to work properly is interrupt virtualization.\nWhile we mostly had to handle M-mode timer interrupts before, Linux virtualization requires proper handling of all kinds of interrupts.\nThe trickiest one was the supervisor external interrupt (",(0,r.jsx)(t.code,{children:"SEI"}),"), which has a different semantic than other interrupt bits: there is not one, but two ",(0,r.jsx)(t.code,{children:"SEI"})," bits, one writable by the hardware, the other by the software, but software can only read the binary ",(0,r.jsx)(t.code,{children:"OR"})," of those two bits."]}),"\n",(0,r.jsxs)(t.p,{children:["We now reached a point where Linux runs smoothly on top of Miralis on the QEMU platform.\nWe tested with both a small BusyBox-based user-space (which we now run against each pull requests in the CI) and a full ubuntu distribution.\nRunning Linux on Miralis is now as simple as executing ",(0,r.jsx)(t.code,{children:"just run linux-shell"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"porting-miralis-to-the-visionfive-2",children:"Porting Miralis to the VisionFive 2"}),"\n",(0,r.jsx)(t.p,{children:"Our second milestone is porting Miralis to the VisionFive 2 board.\nThe VisionFive 2 features a JH7110 SoC, with a quad-core SiFive U74 (RV64GC) processor plus one smaller SiFive S7 (RV64IMAC) monitor core.\nThe feature set of the VisionFive 2 is quite different from what QEMU exposes, which rose quite a few challenges."}),"\n",(0,r.jsxs)(t.p,{children:["The first challenge with the VisionFive 2 was multi-core support.\nNot only is the JH7110 a multi-core platform, but it is also heterogeneous.\nThe smaller SiFive S7 core does not support S-mode, for instance, and has some more restrictions we had to take into account.\nWe added proper multi-core support to Miralis, which required carefully re-designing the initialization sequence and boot assembly to setup disjoint stacks and initialize global resources such as zeroing-out the ",(0,r.jsx)(t.code,{children:".bss"})," section."]}),"\n",(0,r.jsx)(t.p,{children:"Another interesting part is how to insert Miralis in the boot chain.\nWhen the VisionFive 2 boot it starts executing a small read-only bootstrap code, the reset vector, which then jumps to the first writable executable memory.\nThe vendor-provided software boots like this: reset-vector -> u-boot SPL -> OpenSBI -> u-boot proper -> Linux.\nThe first run-time resident firmware in the boot chain is OpenSBI, the role of u-boot SPL is mostly to initialize DRAM and transfer control to the next stage but it does not stay active at run time.\nWe decided to insert Miralis after u-boot SPL, and then transfer control to OpenSBI in the virtual M-mode.\nThat way Miralis is the only M-mode software present at runtime, as OpenSBI runs deprivileged."}),"\n",(0,r.jsxs)(t.p,{children:["Finally the VisionFive 2 has a more limited set of hardware features compared to QEMU.\nOne major difference, for instance, is the lack of support for misaligned reads and writes.\nOn the VisionFive 2 misaligned reads and writes from the kernel are emulated by OpenSBI by changing the memory access privilege (the using the ",(0,r.jsx)(t.code,{children:"MPRV"})," bit in ",(0,r.jsx)(t.code,{children:"mstatus"}),").\nThe ",(0,r.jsx)(t.code,{children:"MPRV"})," bit allow M-mode software to read and write memory as if it was executing with S or U-mode privilege (but instruction fetches keep using M-mode privileges), which simplifies accessing OS memory by removing the need for software page table walk and permission checks.\nHowever the ",(0,r.jsx)(t.code,{children:"MPRV"})," bit can't be enabled while running virtualized firmware with Miralis as the firmware already executes in U-mode.\nWe emulated the ",(0,r.jsx)(t.code,{children:"MPRV"})," bit in Miralis by forcing traps from the firmware to Miralis during reads and writes when the virtual ",(0,r.jsx)(t.code,{children:"MPRV"})," is set to 1, which enables Miralis to emulate the read or write using S or U-mode privileges using the physical ",(0,r.jsx)(t.code,{children:"MPRV"})," bit.\nThere are other differences between QEMU and the VisionFive 2, in particular around devices, but we already managed to close most of the gaps."]}),"\n",(0,r.jsx)(t.h2,{id:"what-is-next",children:"What is next"}),"\n",(0,r.jsxs)(t.p,{children:["With the start of the new academic semester Fran\xe7ois and Fr\xe9d\xe9ric are joining forces to work on Miralis.\nOur objectives for the next few months is to demonstrate how to ",(0,r.jsx)(t.strong,{children:"enforce security policies with Miralis"}),".\nBy default Miralis grants (almost) full access to the machine to the virtualized firmware, therefore it does not provide any security guarantee ",(0,r.jsx)(t.em,{children:"per se"}),".\nThere can be many desirable isolation policies, therefore Miralis does not try to provide the 'one true' security policy, but our goal is rather to enable the implementation of many custom policies.\nFor instance it might be desirable to isolate confidential VMs or enclaves from the firmware and host OS, or even the whole host OS form the firmware."]}),"\n",(0,r.jsx)(t.p,{children:"Overall I am very enthusiastic about Miralis, the project has already gone a long way and built up a very good momentum.\nThere is still a lot on our plate to achieve our vision of securing the lowest layer of the software stack, but I am confident we will get there."})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>n,x:()=>a});var r=i(6540);const s={},o=r.createContext(s);function n(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:n(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);